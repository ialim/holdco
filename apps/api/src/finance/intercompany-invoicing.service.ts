import { Injectable, BadRequestException } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { SubsidiaryRole } from "@prisma/client";
import { Decimal } from "@prisma/client/runtime/library";
import { AgreementType, PricingModel, InvoiceStatus, InvoiceType } from "./finance.enums";
import { LedgerPostingService } from "./ledger-posting.service";
import { PeriodLockService } from "./period-lock.service";
import { assertCompaniesInGroup, assertCompanyInGroup, assertInvoiceInGroup, requireGroupId } from "./finance-tenancy";

function dec(v: any) { return new Decimal(v); }
function round2(d: Decimal) { return new Decimal(d.toFixed(2)); }

function parsePeriod(period: string) {
  const match = /^(\d{4})-(\d{2})$/.exec(period);
  if (!match) {
    throw new BadRequestException("Period must be in YYYY-MM format");
  }
  const year = Number(match[1]);
  const month = Number(match[2]);
  if (Number.isNaN(year) || Number.isNaN(month) || month < 1 || month > 12) {
    throw new BadRequestException("Period must be a valid YYYY-MM value");
  }
  const start = new Date(year, month - 1, 1);
  const end = new Date(year, month, 0, 23, 59, 59, 999);
  return { start, end, year, month };
}

function startOfToday() {
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth(), now.getDate());
}

@Injectable()
export class IntercompanyInvoicingService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly ledgerPostingService: LedgerPostingService,
    private readonly periodLockService: PeriodLockService,
  ) {}

  async generateIntercompanyInvoices(params: {
    groupId: string;
    holdcoCompanyId: string;
    period: string;
    issueDate: Date;
    dueDays?: number;
    charges?: { recipientCompanyId: string; type: AgreementType | string; baseAmount: Decimal | string | number; description?: string }[];
  }) {
    requireGroupId(params.groupId);
    await assertCompanyInGroup(this.prisma, params.groupId, params.holdcoCompanyId, "Holding company");

    const periodWindow = parsePeriod(params.period);
    const issueDay = new Date(
      params.issueDate.getFullYear(),
      params.issueDate.getMonth(),
      params.issueDate.getDate(),
    );
    if (issueDay < periodWindow.start || issueDay > periodWindow.end) {
      throw new BadRequestException("Issue date must fall within the invoicing period");
    }
    if (issueDay < startOfToday()) {
      throw new BadRequestException("Backdating intercompany invoices is not allowed");
    }

    const provider = await this.prisma.subsidiary.findUnique({
      where: { id: params.holdcoCompanyId },
      select: { role: true },
    });
    if (!provider?.role) {
      throw new BadRequestException("Holding company role must be set before generating invoices");
    }
    if (provider.role !== SubsidiaryRole.HOLDCO) {
      throw new BadRequestException("Intercompany invoices must be generated by the holding company");
    }

    const dueDays = params.dueDays ?? 30;
    const charges = params.charges ?? [];
    const providerRole = provider.role;

    if (providerRole === SubsidiaryRole.HOLDCO && charges.length) {
      throw new BadRequestException("Manual charges are only supported for trading or logistics providers");
    }

    if (
      providerRole !== SubsidiaryRole.HOLDCO &&
      providerRole !== SubsidiaryRole.PROCUREMENT_TRADING &&
      providerRole !== SubsidiaryRole.LOGISTICS
    ) {
      throw new BadRequestException("Only holdco, trading, or logistics providers can generate intercompany invoices");
    }

    let allocations: { recipientCompanyId: string; allocatedCost: Decimal }[] = [];
    const chargeGroups: Record<string, { type: AgreementType | string; baseAmount: Decimal; description?: string }[]> = {};

    if (providerRole === SubsidiaryRole.HOLDCO) {
      const pool = await this.prisma.costPool.findUnique({
        where: { companyId_period: { companyId: params.holdcoCompanyId, period: params.period } },
        include: { allocations: true },
      });
      if (!pool) throw new BadRequestException("CostPool not found for period");
      if (!pool.allocations.length) throw new BadRequestException("No allocations found. Run allocate first.");
      allocations = pool.allocations.map((alloc) => ({
        recipientCompanyId: alloc.recipientCompanyId,
        allocatedCost: dec(alloc.allocatedCost),
      }));
    } else {
      if (!charges.length) {
        throw new BadRequestException("Charges are required for non-holdco intercompany invoices");
      }
      for (const charge of charges) {
        const base = dec(charge.baseAmount);
        if (base.lte(0)) {
          throw new BadRequestException("Charge base amount must be greater than 0");
        }
        if (providerRole === SubsidiaryRole.PROCUREMENT_TRADING && charge.type !== AgreementType.PRODUCT_SUPPLY) {
          throw new BadRequestException("Trading charges must use PRODUCT_SUPPLY agreements");
        }
        if (providerRole === SubsidiaryRole.LOGISTICS && charge.type !== AgreementType.LOGISTICS) {
          throw new BadRequestException("Logistics charges must use LOGISTICS agreements");
        }
        chargeGroups[charge.recipientCompanyId] ??= [];
        chargeGroups[charge.recipientCompanyId].push({
          type: charge.type,
          baseAmount: base,
          description: charge.description,
        });
      }
    }

    const agreements = await this.prisma.intercompanyAgreement.findMany({
      where: {
        providerCompanyId: params.holdcoCompanyId,
        effectiveFrom: { lte: params.issueDate },
        OR: [{ effectiveTo: null }, { effectiveTo: { gte: params.issueDate } }],
      },
    });

    const byRecipient: Record<string, { mgmt?: any; ip?: any; product?: any; logistics?: any }> = {};
    for (const ag of agreements) {
      byRecipient[ag.recipientCompanyId] ??= {};
      if (ag.type === AgreementType.MANAGEMENT) byRecipient[ag.recipientCompanyId].mgmt = ag;
      if (ag.type === AgreementType.IP_LICENSE) byRecipient[ag.recipientCompanyId].ip = ag;
      if (ag.type === AgreementType.PRODUCT_SUPPLY) byRecipient[ag.recipientCompanyId].product = ag;
      if (ag.type === AgreementType.LOGISTICS) byRecipient[ag.recipientCompanyId].logistics = ag;
    }

    const recipientIds = providerRole === SubsidiaryRole.HOLDCO
      ? allocations.map((alloc) => alloc.recipientCompanyId)
      : Object.keys(chargeGroups);
    if (recipientIds.length) {
      await assertCompaniesInGroup(this.prisma, params.groupId, recipientIds, "Recipient company");
    }

    const allocationByRecipient = new Map(allocations.map((alloc) => [alloc.recipientCompanyId, alloc]));
    const results: { recipientCompanyId: string; invoiceId: string }[] = [];

    for (const recipientId of recipientIds) {
      const lines: {
        agreementId: string;
        description: string;
        netAmount: Decimal;
        vatRate: Decimal;
        vatAmount: Decimal;
        whtRate: Decimal;
        whtAmount: Decimal;
        grossAmount: Decimal;
      }[] = [];

      if (providerRole === SubsidiaryRole.HOLDCO) {
        const alloc = allocationByRecipient.get(recipientId);
        if (!alloc) continue;

        const mgmtAg = byRecipient[recipientId]?.mgmt;
        const ipAg = byRecipient[recipientId]?.ip;

        if (!mgmtAg || mgmtAg.pricingModel !== PricingModel.COST_PLUS) {
          throw new BadRequestException(`Missing MANAGEMENT COST_PLUS agreement for recipient ${recipientId}`);
        }
        if (!ipAg || ![PricingModel.FIXED_MONTHLY, PricingModel.ROYALTY_PERCENT].includes(ipAg.pricingModel)) {
          throw new BadRequestException(`Missing IP_LICENSE agreement for recipient ${recipientId}`);
        }

        const markup = dec(mgmtAg.markupRate ?? "0.05");
        const mgmtNet = round2(dec(alloc.allocatedCost).mul(dec(1).plus(markup)));
        const mgmtVat = mgmtAg.vatApplies ? round2(mgmtNet.mul(dec(mgmtAg.vatRate))) : dec(0);
        const mgmtWht = mgmtAg.whtApplies ? round2(mgmtNet.mul(dec(mgmtAg.whtRate))) : dec(0);
        const mgmtGross = round2(mgmtNet.plus(mgmtVat));

        lines.push({
          agreementId: mgmtAg.id,
          description: `Management services fee (${params.period}) - cost+${dec(markup).mul(100).toString()}%`,
          netAmount: mgmtNet,
          vatRate: dec(mgmtAg.vatRate),
          vatAmount: mgmtVat,
          whtRate: dec(mgmtAg.whtRate),
          whtAmount: mgmtWht,
          grossAmount: mgmtGross,
        });

        let ipNet = dec(0);
        let ipDescription = `IP/Software license fee (${params.period}) - fixed monthly`;

        if (ipAg.pricingModel === PricingModel.FIXED_MONTHLY) {
          if (!ipAg.fixedFeeAmount) {
            throw new BadRequestException(`IP license fixed fee missing for recipient ${recipientId}`);
          }
          ipNet = round2(dec(ipAg.fixedFeeAmount));
        } else {
          const sales = await this.prisma.invoice.aggregate({
            where: {
              sellerCompanyId: recipientId,
              invoiceType: InvoiceType.EXTERNAL,
              period: params.period,
              status: { not: InvoiceStatus.VOID },
            },
            _sum: { subtotal: true },
          });
          let base = dec(sales._sum.subtotal ?? 0);
          if (base.equals(0)) {
            const orders = await this.prisma.order.aggregate({
              where: {
                subsidiaryId: recipientId,
                createdAt: { gte: periodWindow.start, lte: periodWindow.end },
              },
              _sum: { totalAmount: true },
            });
            base = dec(orders._sum.totalAmount ?? 0);
          }
          const rate = dec(ipAg.markupRate ?? "0.00");
          ipNet = round2(base.mul(rate));
          ipDescription = `IP/Software license fee (${params.period}) - ${rate.mul(100).toString()}% royalty`;
        }
        const ipVat = ipAg.vatApplies ? round2(ipNet.mul(dec(ipAg.vatRate))) : dec(0);
        const ipWht = ipAg.whtApplies ? round2(ipNet.mul(dec(ipAg.whtRate))) : dec(0);
        const ipGross = round2(ipNet.plus(ipVat));

        lines.push({
          agreementId: ipAg.id,
          description: ipDescription,
          netAmount: ipNet,
          vatRate: dec(ipAg.vatRate),
          vatAmount: ipVat,
          whtRate: dec(ipAg.whtRate),
          whtAmount: ipWht,
          grossAmount: ipGross,
        });
      } else {
        const recipientCharges = chargeGroups[recipientId] ?? [];
        for (const charge of recipientCharges) {
          const agreement = charge.type === AgreementType.PRODUCT_SUPPLY
            ? byRecipient[recipientId]?.product
            : byRecipient[recipientId]?.logistics;

          if (!agreement || agreement.pricingModel !== PricingModel.COST_PLUS) {
            throw new BadRequestException(`Missing ${charge.type} COST_PLUS agreement for recipient ${recipientId}`);
          }

          const markup = dec(agreement.markupRate ?? "0.00");
          const net = round2(charge.baseAmount.mul(dec(1).plus(markup)));
          const vat = agreement.vatApplies ? round2(net.mul(dec(agreement.vatRate))) : dec(0);
          const wht = agreement.whtApplies ? round2(net.mul(dec(agreement.whtRate))) : dec(0);
          const gross = round2(net.plus(vat));

          const defaultDescription =
            charge.type === AgreementType.PRODUCT_SUPPLY
              ? `Product supply (${params.period}) - cost+${dec(markup).mul(100).toString()}%`
              : `Logistics services (${params.period}) - cost+${dec(markup).mul(100).toString()}%`;

          lines.push({
            agreementId: agreement.id,
            description: charge.description ?? defaultDescription,
            netAmount: net,
            vatRate: dec(agreement.vatRate),
            vatAmount: vat,
            whtRate: dec(agreement.whtRate),
            whtAmount: wht,
            grossAmount: gross,
          });
        }
      }

      if (!lines.length) continue;

      const subtotal = round2(lines.reduce((sum, line) => sum.plus(line.netAmount), dec(0)));
      const vatAmount = round2(lines.reduce((sum, line) => sum.plus(line.vatAmount), dec(0)));
      const total = round2(lines.reduce((sum, line) => sum.plus(line.grossAmount), dec(0)));

      const dueDate = new Date(params.issueDate);
      dueDate.setDate(dueDate.getDate() + dueDays);

      const existing = await this.prisma.invoice.findFirst({
        where: {
          invoiceType: InvoiceType.INTERCOMPANY,
          sellerCompanyId: params.holdcoCompanyId,
          buyerCompanyId: recipientId,
          period: params.period,
          status: { in: [InvoiceStatus.DRAFT, InvoiceStatus.ISSUED, InvoiceStatus.PART_PAID] },
        },
      });

      const invoice = existing
        ? await this.prisma.invoice.update({
            where: { id: existing.id },
            data: {
              issueDate: params.issueDate,
              dueDate,
              subtotal,
              vatAmount,
              totalAmount: total,
              lines: { deleteMany: {}, create: lines },
            },
          })
        : await this.prisma.invoice.create({
            data: {
              invoiceType: InvoiceType.INTERCOMPANY,
              status: InvoiceStatus.DRAFT,
              sellerCompanyId: params.holdcoCompanyId,
              buyerCompanyId: recipientId,
              period: params.period,
              issueDate: params.issueDate,
              dueDate,
              subtotal,
              vatAmount,
              totalAmount: total,
              lines: { create: lines },
            },
          });

      results.push({ recipientCompanyId: recipientId, invoiceId: invoice.id });
    }

    return { period: params.period, invoices: results };
  }

  async issueInvoice(groupId: string, invoiceId: string) {
    requireGroupId(groupId);
    const invoice = await assertInvoiceInGroup(this.prisma, groupId, invoiceId);
    if (!invoice.period) throw new BadRequestException("Invoice period missing");

    await this.periodLockService.assertNotLocked(invoice.sellerCompanyId, invoice.period);

    const updated = await this.prisma.invoice.update({
      where: { id: invoiceId },
      data: { status: InvoiceStatus.ISSUED },
    });

    await this.ledgerPostingService.postInvoiceToLedger({ groupId, invoiceId });

    return updated;
  }
}
